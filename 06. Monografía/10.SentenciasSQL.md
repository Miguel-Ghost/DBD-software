# Sentencias SQL por cada Prototipo

## 3. Sentencias SQL módulo de Almacén

|                  |                                                                                     |
| ---------------- | --------------------------------------------------------------------------------------------------- |
| Requerimientos relacionados         | R301, R302, R303, R304, R305, R306, R307       |
| Código      | I301 |
| Prototipo   |  ![image](https://github.com/fiis-bd241/grupo01/assets/130816094/2d94b52d-2399-4b9c-a0ef-335f1055378e) |

**Flujo 1**

1. **Botón "Iniciar nuevo proceso":** Lleva al usuario a la pantalla I302.

**Flujo 2**

2. **Selección de tipo búsqueda:** El usuario elige entre realizar la búsqueda del proceso asociado a una mercancía por medio del número de precinto o a un traslado por medio del código de guía de remisión. En base a esto, se ingresa en el campo `<3>` el tipo de entrada elegido por el usario.

3. **Botón "Buscar":** Se realiza la búsqueda usando el valor ingresado por el usuario.

Pero antes, se realizan las siguientes validaciones (dependiendo del tipo de búsqueda):

Validación del número de precinto:

``` sql
SELECT EXISTS (SELECT * FROM mercancia WHERE nro_precinto = <1>)
```

Validación del código de guía de remisión:

``` sql
SELECT EXISTS (SELECT * FROM traslado WHERE cod_guia_remision = <1>)
```

Si alguna validación falla, se muestra un mensaje de error describiendo el problema. De lo contrario, se procede con la búsqueda.

El resultado mostrado se divide en tres secciones: Proceso, Mercancías y Traslado (de existir uno en curso).

Las consultas SQL a ejecutarse son las siquientes, en cada uno de los dos tipos de búsqueda:

**Búsqueda por número de precinto**

Las operaciones asociadas se obtienen con la siguiente consulta:

``` sql
WITH op_picking_cte AS (
SELECT o.id_operacion AS id_op_picking
FROM mercancia m
INNER JOIN operacion o ON m.id_operacion_picking = o.id_operacion
WHERE m.nro_precinto = <3>
)
SELECT o.id_operacion, o.fecha, o.hora_inicio, o.hora_fin,
ot.descripcion AS tipo_operacion,
p1.dni AS dni_emp_ejecutor, p2.dni AS dni_emp_supervisor
FROM operacion o
INNER JOIN operacion_tipo ot ON o.cod_tipo_operacion = ot.cod_tipo_operacion
INNER JOIN empleado e1 ON o.cod_empleado_ejecutor = e1.cod_empleado
INNER JOIN persona p1 ON e1.cod_persona = p1.cod_persona
INNER JOIN empleado e2 ON o.cod_empleado_supervisor = e2.cod_empleado
INNER JOIN persona p2 ON e2.cod_persona = p2.cod_persona
WHERE o.id_operacion = (SELECT id_op_picking FROM op_picking_cte)
OR o.id_operacion_picking = (SELECT id_op_picking FROM op_picking_cte)
ORDER BY o.cod_tipo_operacion;
```

Las mercancías asociadas (es decir, el grupo de mercancías, incluyendo la correspondiente al número de precinto ingresado, que pasaron por las mismas operaciones) se obtienen con la siguiente consulta:

``` sql
SELECT m1.nro_precinto, st.cod_stock, ec.nombre as nombre_stock, ect.descripcion as categoria,
ep.descripcion as tipo, se.descripcion as segmento, ecu.descripcion as unidad,
dm.cantidad as cantidad_transportar
FROM mercancia m1
INNER JOIN mercancia m2 ON m1.id_operacion_picking = m2.id_operacion_picking
INNER JOIN detalle_mercancia_stock dm ON m1.id_mercancia = dm.id_mercancia
INNER JOIN stock st ON dm.id_stock = st.id_stock
INNER JOIN elemento_catalogo ec ON st.id_elemento_catalogo = ec.id_elemento_catalogo
INNER JOIN elemento_catalogo_tipo ect ON ec.id_elemento_catalogo_tipo = ect.id_elemento_catalogo_tipo
INNER JOIN elemento_produccion ep ON ect.id_elemento_produccion = ep.id_elemento_produccion
INNER JOIN elemento_catalogo_unidad ecu ON ec.cod_unidad = ecu.cod_unidad
INNER JOIN segmento se ON ect.id_segmento = se.id_segmento
WHERE m2.nro_precinto = <3>
ORDER BY m1.id_mercancia;
```

El conjunto de filas obtenidas se agrupan por las que tienen el mismo valor del atributo nro_precinto por medio de la lógica implementada en el backend de la aplicación.

Si la mercancía referida ya ha pasado por una operación de tipo "Carga" o, lo que es lo mismo, si la cantidad de operaciones por las que pasó es mayor a 4, se busca la información de traslado (esta lógica se implementa en el backend). La información del traslado se obtiene con la siguiente consulta:

``` sql
SELECT t.cod_guia_remision, r.cod_ruta, rt.descripcion AS tipo_ruta, r.distancia_total, r.duracion,
p.dni AS dni_transportista,
CONCAT(p.primer_apellido, ' ', p.segundo_apellido, ', ', p.prenombre) AS nombre_completo,
n.descripcion AS nacionalidad, v.placa AS placa_vehiculo, vm.descripcion AS modelo_vehiculo,
v.anio_fabricacion, v.capacidad_carga, v.fecha_ultimo_mantenimiento, v.fecha_ultimo_viaje
FROM traslado t
INNER JOIN transportista tr ON t.cod_transportista = tr.cod_transportista
INNER JOIN empleado e ON tr.cod_empleado = e.cod_empleado
INNER JOIN persona p ON e.cod_persona = p.cod_persona
INNER JOIN nacionalidad n ON p.cod_nacionalidad = n.cod_nacionalidad
INNER JOIN ruta r ON t.cod_ruta = r.cod_ruta
INNER JOIN ruta_tipo rt ON r.cod_ruta_tipo = rt.cod_ruta_tipo
INNER JOIN vehiculo v ON t.cod_vehiculo = v.cod_vehiculo
INNER JOIN vehiculo_modelo vm ON v.cod_vehiculo_modelo = vm.cod_vehiculo_modelo
INNER JOIN operacion o ON t.id_operacion_inicia = o.id_operacion
INNER JOIN mercancia m ON o.id_operacion_picking = m.id_operacion_picking
WHERE m.nro_precinto = <3>;
```

**Búsqueda por código de guía de remisión**

Las operaciones asociadas se obtienen con la siguiente consulta:

``` sql
WITH op_picking_cte AS(
SELECT o.id_operacion_picking AS id_op_picking
FROM traslado t
INNER JOIN operacion o on t.id_operacion_inicia = o.id_operacion
WHERE t.cod_guia_remision = <3>
)
SELECT o.id_operacion, o.fecha, o.hora_inicio, o.hora_fin,
ot.descripcion AS tipo_operacion,
p1.dni AS dni_emp_ejecutor, p2.dni AS dni_emp_supervisor
FROM operacion o
INNER JOIN operacion_tipo ot ON o.cod_tipo_operacion = ot.cod_tipo_operacion
INNER JOIN empleado e1 ON o.cod_empleado_ejecutor = e1.cod_empleado
INNER JOIN persona p1 ON e1.cod_persona = p1.cod_persona
INNER JOIN empleado e2 ON o.cod_empleado_supervisor = e2.cod_empleado
INNER JOIN persona p2 ON e2.cod_persona = p2.cod_persona
WHERE o.id_operacion = (SELECT id_op_picking FROM op_picking_cte)
OR o.id_operacion_picking = (SELECT id_op_picking FROM op_picking_cte)
ORDER BY o.cod_tipo_operacion;
```

Las mercancías asociadas al traslado referido se obtienen con la siguiente consulta:

``` sql
SELECT m.nro_precinto, st.cod_stock, ec.nombre as nombre_stock, ect.descripcion as categoria,
ep.descripcion as tipo, se.descripcion as segmento, ecu.descripcion as unidad,
dm.cantidad as cantidad_transportar
FROM traslado t
INNER JOIN operacion o ON t.id_operacion_inicia = o.id_operacion
INNER JOIN mercancia m ON o.id_operacion_picking = m.id_operacion_picking
INNER JOIN detalle_mercancia_stock dm ON m.id_mercancia = dm.id_mercancia
INNER JOIN stock st ON dm.id_stock = st.id_stock
INNER JOIN elemento_catalogo ec ON st.id_elemento_catalogo = ec.id_elemento_catalogo
INNER JOIN elemento_catalogo_tipo ect ON ec.id_elemento_catalogo_tipo = ect.id_elemento_catalogo_tipo
INNER JOIN elemento_produccion ep ON ect.id_elemento_produccion = ep.id_elemento_produccion
INNER JOIN elemento_catalogo_unidad ecu ON ec.cod_unidad = ecu.cod_unidad
INNER JOIN segmento se ON ect.id_segmento = se.id_segmento
WHERE t.cod_guia_remision = <3>
ORDER BY m.id_mercancia;
```

El conjunto de filas obtenidas se agrupan por las que tienen el mismo valor del atributo nro_precinto por medio de la lógica implementada en el backend de la aplicación.

La información del traslado se obtiene con la siguiente consulta:

``` sql
SELECT t.cod_guia_remision, r.cod_ruta, rt.descripcion AS tipo_ruta, r.distancia_total, r.duracion,
p.dni AS dni_transportista,
CONCAT(p.primer_apellido, ' ', p.segundo_apellido, ', ', p.prenombre) AS nombre_completo,
n.descripcion AS nacionalidad, v.placa AS placa_vehiculo, vm.descripcion AS modelo_vehiculo,
v.anio_fabricacion, v.capacidad_carga, v.fecha_ultimo_mantenimiento, v.fecha_ultimo_viaje
FROM traslado t
INNER JOIN transportista tr ON t.cod_transportista = tr.cod_transportista
INNER JOIN empleado e ON tr.cod_empleado = e.cod_empleado
INNER JOIN persona p ON e.cod_persona = p.cod_persona
INNER JOIN nacionalidad n ON p.cod_nacionalidad = n.cod_nacionalidad
INNER JOIN ruta r ON t.cod_ruta = r.cod_ruta
INNER JOIN ruta_tipo rt ON r.cod_ruta_tipo = rt.cod_ruta_tipo
INNER JOIN vehiculo v ON t.cod_vehiculo = v.cod_vehiculo
INNER JOIN vehiculo_modelo vm ON v.cod_vehiculo_modelo = vm.cod_vehiculo_modelo
WHERE t.cod_guia_remision = <3>;
```

La información obtenida de esta búsqueda (en cualquiera de los dos tipos) se muestra en pantalla de la siguiente forma:

![Captura de Pantalla 2024-06-04 a la(s) 23 42 25](https://github.com/fiis-bd241/grupo01/assets/130816094/f21b91f3-6815-45e0-b428-7541b48b2d23)
![Captura de Pantalla 2024-06-04 a la(s) 23 42 41](https://github.com/fiis-bd241/grupo01/assets/130816094/004eff8e-4a0e-41df-9be1-df70fbad82cf)
![Captura de Pantalla 2024-06-04 a la(s) 23 43 13](https://github.com/fiis-bd241/grupo01/assets/130816094/7d6d8ff5-7f65-4f7d-9d41-65183f76c654)
![Captura de Pantalla 2024-06-04 a la(s) 23 43 22](https://github.com/fiis-bd241/grupo01/assets/130816094/f1ca591b-c45d-4224-95e6-de6d5207876f)

Los estados del Proceso y del Traslado se obtienen según la cantidad de operaciones registradas. Esta lógica se implementa en el backend.

4. **Botón "Registrar operación":** Lleva al usuario a la pantalla adecuada para registrar una operación adicional del proceso encontrado. Es decir, si la última operación registrada del proceso encontrado es de tipo "Picking", se lleva al usuario a la pantalla I304; si es de tipo "Precintado", a la pantalla I305; si es de tipo "Paletizado", a la pantalla I306; si es de tipo "Carga", a la pantalla I307; si es de tipo "Salida", a la pantalla I309; y si es de tipo "Recepción", a la pantalla I310. Si es de tipo "Descarga", el botón "Registrar operación" no se habilita. Toda esta lógica descrita se implementa en el frontend. Además, el valor del atributo "id_operacion" de la primera operación (de tipo "picking") se pasa como un parámetro llamado "id_operacion_picking" a esta nueva pantalla. 

|                  |                                                                                     |
| ---------------- | --------------------------------------------------------------------------------------------------- |
| Requerimientos relacionados         | R301           |
| Código      | I302 |
| Prototipo   |  ![image](https://github.com/fiis-bd241/grupo01/assets/130816094/78136d2c-1f37-4b1f-a89d-61edf840dbbb) |

1.  **Carga de página:** El campo "Fecha" se autocompleta con la fecha actual.

2. **Botón "Agregar mercancía":** Al presionar este botón, se muestra la pantalla I303. Se retorna con un código de stock y su cantidad a transportar, que forman una mercancía. Al hacer esto, se crean dos tipos de botones por cada mercancía, los cuales identificaremos como "*" y "**", como se muestra en la siguiente imagen:

![image](https://github.com/fiis-bd241/grupo01/assets/130816094/00796911-bc32-45a2-b0f0-d3b594f5c973)

*. Este botón lleva al usuario a la pantalla I303. Se realiza el mismo proceso, con la única diferencia de que el código de stock y su cantidad a transportar se ingresan en una mercancía determinada.

**. Este botón elimina el código de stock y su cantidad a transportar en una mercancía y fila determinadas.

La lógica descrita se implementa en el frontend.

3. **Botón "Ingresar":** Se realizan las siguientes validaciones:

Validación del DNI del empleado ejecutor:

``` sql
SELECT EXISTS (SELECT *
FROM empleado e
INNER JOIN persona p on p.cod_persona = e.cod_persona
WHERE p.dni = <5>)
```

Validación del DNI del empleado supervisor:

``` sql
SELECT EXISTS (SELECT *
FROM empleado e
INNER JOIN persona p on p.cod_persona = e.cod_persona
WHERE p.dni = <6>)
```

Si alguna validación falla, se muestra un mensaje de error describiendo el problema. De lo contrario, se ingresan a la base de datos los valores ingresados por medio de la siguiente sentencia SQL:

``` sql
INSERT INTO operacion (id_operacion_picking, cod_empleado_ejecutor, cod_empleado_supervisor, cod_tipo_operacion, fecha, hora_inicio, hora_fin)
VALUES (
NULL,
(SELECT e.cod_empleado FROM empleado e JOIN persona p ON e.cod_persona = p.cod_persona WHERE p.dni = <5>),
(SELECT e.cod_empleado FROM empleado e JOIN persona p ON e.cod_persona = p.cod_persona WHERE p.dni = <6>),
1,
<2>,
<3>,
<4>
)
RETURNING id_operacion;
```
El valor retornado por esta sentencia se almacena en una variable en el backend. Sea esta variable "id_operacion_picking".

Para cada "mercancía", conformada por varios pares de valores de id_stock y su cantidad a transportar, se ejecuta la siguiente sentencia SQL:

``` sql
INSERT INTO mercancia (id_operacion_picking) VALUES (<id_operacion_picking>) RETURNING id_mercancia
```

Sea "id_mercancia" el valor retornado por esta sentencia. Mediante un método implementado en el backend que toma como entradas los valores de las variables "id_operacion_picking" e "id_mercancia" se genera el valor del número de precinto de esta mercancía y se almacena en la variable "nro_precinto". Para cada mercancía se ejecuta la siguiente sentencia SQL:

``` sql
UPDATE mercancia SET nro_precinto = <nro_precinto> WHERE id_mercancia = <id_mercancia>
```

Para cada par de valores id_stock y cantidad de esta mercancía se ejecutan las siguientes sentencias SQL:

``` sql
INSERT INTO detalle_mercancia_stock (id_mercancia, id_stock, cantidad) VALUES (<id_mercancia>, <id_stock>, <cantidad>)
```

``` sql
UPDATE stock SET cantidad_disponible = cantidad_disponible - <cantidad> WHERE id_stock = <id_stock>
```

Se exporta en PDF los números de precinto generados con los detalles de cada mercancía.

Finalmente, se lleva al usuario a la pantalla I311.

|                  |                                                                                     |
| ---------------- | --------------------------------------------------------------------------------------------------- |
| Requerimientos relacionados         | R301           |
| Código      | I303 |
| Prototipo   | ![image](https://github.com/fiis-bd241/grupo01/assets/130816094/bb65ce7e-6483-478e-acc1-372cec7aa13b) |

1. **Botón "Buscar":** Se busca el código de stock ingresado por el usuario. Se muestra en pantalla la información de este stock usando la siguiente consulta:

``` sql
SELECT st.id_stock as id, ec.nombre as nombre, ect.descripcion as categoria,
ep.descripcion as tipo, se.descripcion as segmento, ecu.descripcion as unidad
FROM stock st
INNER JOIN elemento_catalogo ec ON st.id_elemento_catalogo = ec.id_elemento_catalogo
INNER JOIN elemento_catalogo_tipo ect ON ec.id_elemento_catalogo_tipo = ect.id_elemento_catalogo_tipo
INNER JOIN elemento_produccion ep ON ect.id_elemento_produccion = ep.id_elemento_produccion
INNER JOIN elemento_catalogo_unidad ecu ON ec.cod_unidad = ecu.cod_unidad
INNER JOIN segmento se ON ect.id_segmento = se.id_segmento
WHERE st.cod_stock = <1>
```

2. **Botón "Ingresar":** Ingresa el código de stock especificado a la pantalla I302. Lleva al usuario de vuelta a la pantalla I302.

3. **Botón "Cerrar":** Lleva al usuario de vuelta a la pantalla I302. 

|                  |                                                                                     |
| ---------------- | --------------------------------------------------------------------------------------------------- |
| Requerimientos relacionados         | R302           |
| Código      | I304 |
| Prototipo   | ![image](https://github.com/fiis-bd241/grupo01/assets/130816094/c3c802ca-5d15-412d-811f-d41d80b8db65) |

1.  **Carga de página:** Para llegar a esta pantalla, necesariamente se debe partir desde la pantalla I301 o I311. En ambos casos, se asigna el valor pasado como parámetro a la variable "id_operacion_picking". El campo "Fecha" se autocompleta con la fecha actual.

2.  **Botón "Ingresar":** Se realizan las siguientes validaciones:

Validación del DNI del empleado ejecutor:

``` sql
SELECT EXISTS (SELECT *
FROM empleado e
INNER JOIN persona p on p.cod_persona = e.cod_persona
WHERE p.dni = <4>)
```

Validación del DNI del empleado supervisor:

``` sql
SELECT EXISTS (SELECT *
FROM empleado e
INNER JOIN persona p on p.cod_persona = e.cod_persona
WHERE p.dni = <5>)
```
Si alguna validación falla, se muestra un mensaje de error describiendo el problema. De lo contrario, se ingresan a la base de datos los valores ingresados por medio de la siguiente sentencia SQL:

``` sql
INSERT INTO operacion (id_operacion_picking, cod_empleado_ejecutor, cod_empleado_supervisor, cod_tipo_operacion, fecha, hora_inicio, hora_fin)
VALUES (
<id_operacion_picking>,
(SELECT e.cod_empleado FROM empleado e JOIN persona p ON e.cod_persona = p.cod_persona WHERE p.dni = <4>),
(SELECT e.cod_empleado FROM empleado e JOIN persona p ON e.cod_persona = p.cod_persona WHERE p.dni = <5>),
2,
<1>,
<2>,
<3>
)
RETURNING id_operacion;
```

Se muestra al usuario la pantalla I311.

|                  |                                                                                     |
| ---------------- | --------------------------------------------------------------------------------------------------- |
| Requerimientos relacionados         | R303           |
| Código      | I305 |
| Prototipo   | ![image](https://github.com/fiis-bd241/grupo01/assets/130816094/67a7b049-5fbb-48b6-85ac-07ca889511ff) |

1.  **Carga de página:** Para llegar a esta pantalla, necesariamente se debe partir desde la pantalla I301 o I311. En ambos casos, se asigna el valor pasado como parámetro a la variable "id_operacion_picking". El campo "Fecha" se autocompleta con la fecha actual.

2.  **Botón "Ingresar":** Se realizan las siguientes validaciones:

Validación del DNI del empleado ejecutor:

``` sql
SELECT EXISTS (SELECT *
FROM empleado e
INNER JOIN persona p on p.cod_persona = e.cod_persona
WHERE p.dni = <4>)
```

Validación del DNI del empleado supervisor:

``` sql
SELECT EXISTS (SELECT *
FROM empleado e
INNER JOIN persona p on p.cod_persona = e.cod_persona
WHERE p.dni = <5>)
```
Si alguna validación falla, se muestra un mensaje de error describiendo el problema. De lo contrario, se ingresan a la base de datos los valores ingresados por medio de la siguiente sentencia SQL:

``` sql
INSERT INTO operacion (id_operacion_picking, cod_empleado_ejecutor, cod_empleado_supervisor, cod_tipo_operacion, fecha, hora_inicio, hora_fin)
VALUES (
<id_operacion_picking>,
(SELECT e.cod_empleado FROM empleado e JOIN persona p ON e.cod_persona = p.cod_persona WHERE p.dni = <4>),
(SELECT e.cod_empleado FROM empleado e JOIN persona p ON e.cod_persona = p.cod_persona WHERE p.dni = <5>),
3,
<1>,
<2>,
<3>
)
RETURNING id_operacion;
```

Se muestra al usuario la pantalla I311.

|                  |                                                                                     |
| ---------------- | --------------------------------------------------------------------------------------------------- |
| Requerimientos relacionados         | R304           |
| Código      | I306 |
| Prototipo   | ![image](https://github.com/fiis-bd241/grupo01/assets/130816094/df11747a-b3a6-488b-aff9-914c9bef5058) |

1.  **Carga de página:** Para llegar a esta pantalla, necesariamente se debe partir desde la pantalla I301 o I311. En ambos casos, se asigna el valor pasado como parámetro a la variable "id_operacion_picking". El campo "Fecha" se autocompleta con la fecha actual.

2.  **Botón "Ingresar":** Se realizan las siguientes validaciones:

Validación del DNI del empleado ejecutor:

``` sql
SELECT EXISTS (SELECT *
FROM empleado e
INNER JOIN persona p on p.cod_persona = e.cod_persona
WHERE p.dni = <4>)
```

Validación del DNI del empleado supervisor:

``` sql
SELECT EXISTS (SELECT *
FROM empleado e
INNER JOIN persona p on p.cod_persona = e.cod_persona
WHERE p.dni = <5>)
```
Si alguna validación falla, se muestra un mensaje de error describiendo el problema. De lo contrario, se ingresan a la base de datos los valores ingresados por medio de la siguiente sentencia SQL:

``` sql
INSERT INTO operacion (id_operacion_picking, cod_empleado_ejecutor, cod_empleado_supervisor, cod_tipo_operacion, fecha, hora_inicio, hora_fin)
VALUES (
<id_operacion_picking>,
(SELECT e.cod_empleado FROM empleado e JOIN persona p ON e.cod_persona = p.cod_persona WHERE p.dni = <4>),
(SELECT e.cod_empleado FROM empleado e JOIN persona p ON e.cod_persona = p.cod_persona WHERE p.dni = <5>),
4,
<1>,
<2>,
<3>
)
RETURNING id_operacion;
```

Se muestra al usuario la pantalla I311.

|                  |                                                                                     |
| ---------------- | --------------------------------------------------------------------------------------------------- |
| Requerimientos relacionados         | R305           |
| Código      | I307 |
| Prototipo   | ![image](https://github.com/fiis-bd241/grupo01/assets/130816094/1dd1d070-1790-4e0d-bea9-bb417b755f72) |

1.  **Carga de página:** Para llegar a esta pantalla, necesariamente se debe partir desde la pantalla I301 o I311. En ambos casos, se asigna el valor pasado como parámetro a la variable "id_operacion_picking". El campo "Fecha" se autocompleta con la fecha actual.

2. **Botón "Agregar pedido":** Identificado con el número 6 en la imagen. Lleva al usuario a la pantalla I308. Retorna un código de pedido que se agrega en pantalla.

3. **Botón "Eliminar pedido":** Identificado con el número 7 en la imagen. Elimina un código de pedido.

4.  **Botón "Ingresar":** Se realizan las siguientes validaciones:

Validación del DNI del empleado ejecutor:

``` sql
SELECT EXISTS (SELECT *
FROM empleado e
INNER JOIN persona p on p.cod_persona = e.cod_persona
WHERE p.dni = <4>)
```

Validación del DNI del empleado supervisor:

``` sql
SELECT EXISTS (SELECT *
FROM empleado e
INNER JOIN persona p on p.cod_persona = e.cod_persona
WHERE p.dni = <5>)
```

Validación del código de ruta:

``` sql
SELECT EXISTS (SELECT * FROM ruta WHERE cod_ruta = <8>)
```

Validación de la placa del vehículo:

``` sql
SELECT EXISTS (SELECT * FROM vehiculo WHERE placa = <9>)
```

Validación del DNI del transportista:

``` sql
SELECT EXISTS (SELECT *
FROM transportista t
INNER JOIN empleado e ON t.cod_empleado = e.cod_empleado
INNER JOIN persona p ON e.cod_persona = p.cod_persona
WHERE p.dni = <10>)
```

Si alguna validación falla, se muestra un mensaje de error describiendo el problema. De lo contrario, se ingresan a la base de datos los valores ingresados por medio de la siguiente sentencia SQL:

``` sql
INSERT INTO operacion (id_operacion_picking, cod_empleado_ejecutor, cod_empleado_supervisor, cod_tipo_operacion, fecha, hora_inicio, hora_fin)
VALUES (
<id_operacion_picking>,
(SELECT e.cod_empleado FROM empleado e JOIN persona p ON e.cod_persona = p.cod_persona WHERE p.dni = <4>),
(SELECT e.cod_empleado FROM empleado e JOIN persona p ON e.cod_persona = p.cod_persona WHERE p.dni = <5>),
5,
<1>,
<2>,
<3>
)
RETURNING id_operacion;
```

El valor retornado por esta sentencia se almacena en una variable en el backend. Sea esta variable "id_operacion". Esta operación de tipo "Salida" marca el inicio de un traslado. Con la siguiente sentencia se inserta la fila respectiva en la tabla traslado con el id de la operación registrada.

``` sql
INSERT INTO traslado (cod_vehiculo, cod_ruta, cod_transportista, id_operacion_inicia)
VALUES
((SELECT cod_vehiculo FROM vehiculo WHERE placa = <9>),
<8>,
(SELECT t.cod_transportista
FROM transportista t
INNER JOIN empleado e on t.cod_empleado = e.cod_empleado
INNER JOIN persona p on p.cod_persona = e.cod_persona
WHERE p.dni = <10>),
<id_operacion>)
RETURNING id_traslado;
```

El valor retornado por esta sentencia se almacena en una variable en el backend. Sea esta variable "id_traslado". Con la siguiente sentencia se genera el código de guía remisión de 21 dígitos usando las variables "id_traslado" e "id_operacion".

``` sql
SELECT LPAD(CAST(<id_traslado> AS TEXT), 5, '0') ||
TO_CHAR(o.fecha, 'YYYYMMDD') || TO_CHAR(o.hora_inicio, 'HH24MI') || TO_CHAR(o.hora_fin, 'HH24MI')
FROM operacion o WHERE o.id_operacion = <id_operacion>
```

El valor retornado por esta sentencia se almacena en una variable en el backend. Sea esta variable "cod_guia_remision". Con la siguiente sentencia se actualiza en la fila de la tabla traslado insertada este código de guía remisión:

``` sql
UPDATE traslado SET cod_guia_remision = <cod_guia_remision> WHERE id_traslado = <id_traslado>
```

En la parte del frontend, se almacena en una estructura de datos los códigos de pedido ingresados por el usuario. Sea cada uno de estos códigos representado por la variable "cod_pedido". Para cada uno de estos valores se ejecuta la siguiente sentencia:

``` sql
INSERT INTO detalle_ticket_traslado(id_traslado, cod_ticket)
VALUES (
id_traslado>,
(SELECT t.cod_ticket
FROM ticket t
INNER JOIN pedido p ON t.cod_ticket = p.cod_ticket
WHERE p.cod_pedido = <cod_pedido>)
);
```

Se muestra al usuario la pantalla I311.

|                  |                                                                                     |
| ---------------- | --------------------------------------------------------------------------------------------------- |
| Requerimientos relacionados         | R305           |
| Código      | I308 |
| Prototipo   | ![image](https://github.com/fiis-bd241/grupo01/assets/130816094/708bd7b5-63fb-4515-a478-a3ac052d7301) |

1. **Botón "Agregar":** Se realiza la siguiente validación:

Validación del código de pedido:

``` sql
SELECT EXISTS (SELECT * FROM pedido WHERE cod_pedido = <1>)
```

Si alguna validación falla, se muestra un mensaje de error describiendo el problema. De lo contrario, se agrega el código de pedido agregado en el campo `<1>`. Regresa al usuario a la pantalla I307.

2. **Botón "Cerrar":** Regresa al usuario a la pantalla I307.

|                  |                                                                                     |
| ---------------- | --------------------------------------------------------------------------------------------------- |
| Requerimientos relacionados         | R306           |
| Código      | I309 |
| Prototipo   | ![image](https://github.com/fiis-bd241/grupo01/assets/130816094/dc002a04-4c28-4deb-bb7d-2da7d3f92294) |

1.  **Carga de página:** Para llegar a esta pantalla, necesariamente se debe partir desde la pantalla I301 o I311. En ambos casos, se asigna el valor pasado como parámetro a la variable "id_operacion_picking". El campo "Fecha" se autocompleta con la fecha actual.

2.  **Botón "Ingresar":** Se realizan las siguientes validaciones:

Validación del DNI del empleado ejecutor:

``` sql
SELECT EXISTS (SELECT *
FROM empleado e
INNER JOIN persona p on p.cod_persona = e.cod_persona
WHERE p.dni = <4>)
```

Validación del DNI del empleado supervisor:

``` sql
SELECT EXISTS (SELECT *
FROM empleado e
INNER JOIN persona p on p.cod_persona = e.cod_persona
WHERE p.dni = <5>)
```
Si alguna validación falla, se muestra un mensaje de error describiendo el problema. De lo contrario, se ingresan a la base de datos los valores ingresados por medio de la siguiente sentencia SQL:

``` sql
INSERT INTO operacion (id_operacion_picking, cod_empleado_ejecutor, cod_empleado_supervisor, cod_tipo_operacion, fecha, hora_inicio, hora_fin)
VALUES (
<id_operacion_picking>,
(SELECT e.cod_empleado FROM empleado e JOIN persona p ON e.cod_persona = p.cod_persona WHERE p.dni = <4>),
(SELECT e.cod_empleado FROM empleado e JOIN persona p ON e.cod_persona = p.cod_persona WHERE p.dni = <5>),
6,
<1>,
<2>,
<3>
)
RETURNING id_operacion;
```
El valor retornado por esta sentencia se almacena en una variable en el backend. Sea esta variable "id_operacion". Esta operación de tipo "Recepción" marca el fin de un traslado. Con la siguiente sentencia se actualiza la fila respectiva de la tabla traslado con el id de la operación registrada.

``` sql
UPDATE traslado
SET id_operacion_termina = <id_operacion>
FROM traslado t
INNER JOIN operacion o ON t.id_operacion_inicia = o.id_operacion
WHERE o.id_operacion_picking = <id_operacion_picking>;
```

Se muestra al usuario la pantalla I311.

|                  |                                                                                     |
| ---------------- | --------------------------------------------------------------------------------------------------- |
| Requerimientos relacionados         | R307           |
| Código      | I310 |
| Prototipo   | ![image](https://github.com/fiis-bd241/grupo01/assets/130816094/895a7907-cb6d-41d8-ba74-0d42f367bc5c) |

1.  **Carga de página:** Para llegar a esta pantalla, necesariamente se debe partir desde la pantalla I301 o I311. En ambos casos, se asigna el valor pasado como parámetro a la variable "id_operacion_picking". El campo "Fecha" se autocompleta con la fecha actual.

2.  **Botón "Ingresar":** Se realizan las siguientes validaciones:

Validación del DNI del empleado ejecutor:

``` sql
SELECT EXISTS (SELECT *
FROM empleado e
INNER JOIN persona p on p.cod_persona = e.cod_persona
WHERE p.dni = <4>)
```

Validación del DNI del empleado supervisor:

``` sql
SELECT EXISTS (SELECT *
FROM empleado e
INNER JOIN persona p on p.cod_persona = e.cod_persona
WHERE p.dni = <5>)
```
Si alguna validación falla, se muestra un mensaje de error describiendo el problema. De lo contrario, se ingresan a la base de datos los valores ingresados por medio de la siguiente sentencia SQL:

``` sql
INSERT INTO operacion (id_operacion_picking, cod_empleado_ejecutor, cod_empleado_supervisor, cod_tipo_operacion, fecha, hora_inicio, hora_fin)
VALUES (
<id_operacion_picking>,
(SELECT e.cod_empleado FROM empleado e JOIN persona p ON e.cod_persona = p.cod_persona WHERE p.dni = <4>),
(SELECT e.cod_empleado FROM empleado e JOIN persona p ON e.cod_persona = p.cod_persona WHERE p.dni = <5>),
7,
<1>,
<2>,
<3>
)
RETURNING id_operacion;
```

Se muestra al usuario la pantalla I311.

|                  |                                                                                     |
| ---------------- | --------------------------------------------------------------------------------------------------- |
| Requerimientos relacionados         | R301, R302, R303, R304, R305, R306, R307       |
| Código      | I311 |
| Prototipo   | ![image](https://github.com/fiis-bd241/grupo01/assets/130816094/aa2aaad7-735b-4a08-a67f-9777d4b7651f) |

1. **Botón "Volver a vista de procesoss":** Lleva al usuario a la pantalla I301.

2. **Botón "Continuar siguiente operación":** Lleva al usuario a la pantalla adecuada para registrar una operación adicional del proceso en cuestión. Es decir, si la pantalla actual es de tipo "Picking", se lleva al usuario a la pantalla I304; si es de tipo "Precintado", a la pantalla I305; si es de tipo "Paletizado", a la pantalla I306; si es de tipo "Carga", a la pantalla I307; si es de tipo "Salida", a la pantalla I309; y si es de tipo "Recepción", a la pantalla I310. Si es de tipo "Descarga", el botón "Continuar siguiente operación" no se habilita. Toda esta lógica descrita se implementa en el frontend. Además, el valor del atributo "id_operacion_picking" de la pantalla actual se pasa como un parámetro llamado "id_operacion_picking" a esta nueva pantalla. 

En el caso de que la pantalla actual sea de tipo "Salida", en el mensaje de confirmación se muestra el código de guía de remisión generado, como se ve en la imagen a continuación.

![Captura de Pantalla 2024-06-04 a la(s) 23 58 50](https://github.com/fiis-bd241/grupo01/assets/130816094/f6356122-ad6b-43c2-bd22-aafe36a1622b)

En el caso de que la pantalla actual sea de tipo "Descarga", como se mencionó, este botón no se habilita, como se ve en la imagen a continuación.

![Captura de Pantalla 2024-06-05 a la(s) 00 00 37](https://github.com/fiis-bd241/grupo01/assets/130816094/96817a5a-28b2-4a37-a0c5-ccc1b4994a06)

## 4. Sentencias SQL módulo de Control

### Caso 1
<table>
   <tr>
      <td>Código Requerimiento</td>
      <td>R401</td>
   </tr>
   <tr>
      <td>Código interfaz</td>
      <td>I401</td>
   </tr>
   <tr>
      <td>Imagen interfaz</td>
      <td>
         <img src="https://github.com/Alexclb0/Holamundo/assets/164266999/5468b073-0253-46e4-9c92-a86ee9ddae30">
      </td>
   </tr>
   <tr>
      <td colspan="2">Sentencias SQL</td>
   </tr>
</table>

### Evento:
### Ver conductores: 
Se mostrará en pantalla la lista de todos los conductores para poder registrar su disponibilidad en base a los datos correspondiente a cada uno.
``` sql
SELECT 
    t.cod_transportista AS "Código del Conductor",
    t.cod_empleado AS "Código del Empleado",
    lt.descripcion AS "Tipo de Licencia",
    t.fecha_vencimiento_licencia AS "Fecha de Vencimiento de Licencia",
    t.fecha_ultimo_traslado AS "Fecha Último Traslado",
    te.descripcion AS "Estado del Conductor"
FROM 
    transportista t
JOIN 
    licencia_tipo lt ON t.cod_tipo_licencia = lt.cod_tipo_licencia
JOIN 
    transportista_estado te ON t.cod_estado_transportista = te.cod_estado_transportista;
```

### Caso 2
<table>
   <tr>
      <td>Código Requerimiento</td>
      <td>R401</td>
   </tr>
   <tr>
      <td>Código interfaz</td>
      <td>I401</td>
   </tr>
   <tr>
      <td>Imagen interfaz</td>
      <td>
         <img src="https://github.com/Alexclb0/Holamundo/assets/164266999/a36b2b4b-8654-44ec-a3ba-df7ff85c4d1e">
      </td>
   </tr>
   <tr>
      <td colspan="2">Sentencias SQL</td>
   </tr>
</table>

### Evento:
### Botón Estado: 
El botón sirve para que el administrador pueda cambiar el estado de disponibilidad del conductor  que puede ser Disponible, No Disponible y Cuarentena.
``` sql
UPDATE Transportista SET cod_estado_transportista = <1> WHERE cod_estado_transportista = 2 AND cod_transportista = <2>
```

### Caso 3
<table>
   <tr>
      <td>Código Requerimiento</td>
      <td>R402</td>
   </tr>
   <tr>
      <td>Código interfaz</td>
      <td>I402</td>
   </tr>
   <tr>
      <td>Imagen interfaz</td>
      <td>
         <img src="https://github.com/Alexclb0/Holamundo/assets/164266999/41c637e5-bdc6-4ed0-8dd5-562eeef707cb">
      </td>
   </tr>
   <tr>
      <td colspan="2">Sentencias SQL</td>
   </tr>
</table>

### Evento:
### Ver Vehículos: 
Se mostrará en pantalla la lista de todos los vehículos para poder registrar su disponibilidad en base a los datos correspondiente a cada uno.
``` sql
SELECT 
    v.cod_vehiculo AS "Código Vehículo",
    v.año_fabricacion AS "Año Fabricación",
    v.fecha_ultimo_mantenimiento AS "Fecha Último Mantenimiento",
    v.capacidad_carga AS "Capacidad de Carga",
    vm.descripcion AS "Marca",
    v.placa AS "Placa",
    v.fecha_ultimo_viaje AS "Fecha Último Viaje",
    ve.descripcion AS "Estado del Vehículo"
FROM 
    vehiculo v
JOIN 
    vehiculo_modelo vm ON v.cod_vehiculo_modelo = vm.cod_vehiculo_modelo
JOIN 
    vehiculo_estado ve ON v.cod_vehiculo_estado = ve.cod_vehiculo_estado

```

### Caso 4
<table>
   <tr>
      <td>Código Requerimiento</td>
      <td>R402</td>
   </tr>
   <tr>
      <td>Código interfaz</td>
      <td>I402</td>
   </tr>
   <tr>
      <td>Imagen interfaz</td>
      <td>
         <img src="https://github.com/Alexclb0/Holamundo/assets/164266999/edd1ee65-2adb-45c4-9058-8d5c27c0e206">
      </td>
   </tr>
   <tr>
      <td colspan="2">Sentencias SQL</td>
   </tr>
</table>

### Evento:
### Botón estado: 
El botón sirve para que el administrador pueda cambiar el estado de disponibilidad del vehículo  que puede ser Disponible, No Disponible y Cuarentena.
``` sql
UPDATE Vehículo SET cod_estado_vehiculo = <1> WHERE cod_estado_vehiculo = 2 AND cod_vehiculo = <2>

```

### Caso 5
<table>
   <tr>
      <td>Código Requerimiento</td>
      <td>R403</td>
   </tr>
   <tr>
      <td>Código interfaz</td>
      <td>I403,I404,I405,I406,I407</td>
   </tr>
   <tr>
      <td>Imagen interfaz</td>
      <td>
         <img src="https://github.com/Alexclb0/Holamundo/assets/164266999/a54903b4-1a59-4620-bf74-38885420d54e">
         <img src="https://github.com/Alexclb0/Holamundo/assets/164266999/7721353f-20f2-41e9-a837-bc1c2005fd9c">
         <img src="https://github.com/Alexclb0/Holamundo/assets/164266999/617f5b07-1d3c-4370-ab8c-39bd08ad88d3">
         <img src="https://github.com/Alexclb0/Holamundo/assets/164266999/e95d453b-0427-48ee-8a46-e54368231569">
      </td>
   </tr>
   <tr>
      <td colspan="2">Sentencias SQL</td>
   </tr>
</table>

### Evento:
### Nueva incidencia: 
El administrador podrá registrar una nueva incidencia seleccionando primero el tipo de incidencia que se presenta. Dependiendo de la opción elegida, se determinará un tipo de procedimiento específico, cuya selección dependerá del empleado y del contexto de la situación. Este procedimiento elegido se basará en un tipo de norma aplicable.

1. Se llenará la lista de tipos de incidencia según el contexto que se presentase.

``` sql 
SELECT * FROM incidencia_tipo;
```

2. Se seleccionará el tipo de procedimiento a efectuar en base a determinado tipo de incidencia. 

``` sql 
SELECT * FROM procedimiento_tipo;
```

3. Se seleccionará el tipo de norma en las cuales se basa cada procedimiento.

``` sql 
SELECT * FROM norma_tipo;
```

4. Al apretar el botón Registrar se actualiza el código del tipo de incidencia, el tipo de procedimiento, la descripción detallada de la incidencia, tipo de norma, fecha de ocurrencia, hora de ocurrencia, tiempo estimado de procedimiento (en horas).

``` sql 
UPDATE incidencia
SET cod_tipo_incidencia = <1>, cod_tipo_procedimiento =<2>, descripcion = <3>, cod_norma_tipo = <4>, fecha_ocurrencia=<5>, hora_ocurrencia=<6>, id_traslado=<7>, tiempo_estimado=<8> 
WHERE incidencia.cod_incidencia = <9>
```
Donde <1> es el código del tipo de incidencia escogido por el empleado, tomando en cuenta el contexto presentado. 

Donde <2> es el código del tipo de procedimiento escogido por el empleado, tomando en cuenta el contexto presentado. 

Donde <3> es la descripción a detalle de la incidencia, escrita por el empleado.

Donde <4> es el código del tipo de norma escogido por el empleado, tomando en cuenta el contexto presentado. 

Donde <5> es la fecha en la que ocurrió la incidencia, registrada por el empleado. 

Donde <6> es la hora exacta en la que ocurrió la incidencia, registrada por el empleado. 

Donde <7> es el código del traslado, en el cual se presentó determinada incidencia. 

Donde <8> es el tiempo estimado en horas de la duración del procedimiento.

Donde <9> es el código de la incidencia actual. 


### Caso 6
<table>
   <tr>
      <td>Código Requerimiento</td>
      <td>R403</td>
   </tr>
   <tr>
      <td>Código interfaz</td>
      <td>I407</td>
   </tr>
   <tr>
      <td>Imagen interfaz</td>
      <td>
         <img src="https://github.com/fiis-bd241/grupo01/assets/164266999/dfd1cd46-edc9-4934-a378-9dac58e0f49a">
      </td>
   </tr>
   <tr>
      <td colspan="2">Sentencias SQL</td>
   </tr>
</table>

### Evento:
### Ver Incidencias: 
Se mostrará en pantalla la lista de todas las incidencias para poder registrar el grado de atención brindado en base a los datos correspondiente a cada uno.

``` sql
SELECT 
    i.cod_incidencia AS "Código Incidencia",
    i.id_traslado AS "Código Traslado",
    it.descripcion AS "Tipo de Incidencia",
    i.fecha_ocurrencia AS "Fecha de Ocurrencia",
    i.hora_ocurrencia AS "Hora de Ocurrencia",
    i.cod_estado_incidencia AS "Estado Incidencia"
FROM 
    incidencia i
JOIN 
    incidencia_tipo it ON i.cod_tipo_incidencia = it.cod_tipo_incidencia;

```

### Caso 7
<table>
   <tr>
      <td>Código Requerimiento</td>
      <td>R404</td>
   </tr>
   <tr>
      <td>Código interfaz</td>
      <td>I407</td>
   </tr>
   <tr>
      <td>Imagen interfaz</td>
      <td>
         <img src="https://github.com/fiis-bd241/grupo01/assets/164266999/98f05098-900c-4e63-9d0b-eab06cd2cac9">
      </td>
   </tr>
   <tr>
      <td colspan="2">Sentencias SQL</td>
   </tr>
</table>

### Evento:
### Botón estado: 
El botón sirve para que el administrador pueda cambiar el estado de atención de la incidencia  que puede ser Solucionado o Pendiente. 
``` sql
UPDATE incidencia SET cod_estado_incidencia = <1> WHERE cod_estado_incidencia = 2 AND cod_incidencia = <2>

```
